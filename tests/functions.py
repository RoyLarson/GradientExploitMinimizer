import time

def sleeper(seconds, func):
    def wrapt(*args, **kwargs):
        time.sleep(seconds)
        return func(*args, **kwargs)
    return wrapt

def circle_exclusion(center_1, center_2, radius, wrapt_fun, x1, x2):
    if np.sqrt((x1-center_1)^2+(x2-center_2)^2)<=radius:
        return np.inf
    else:
        return wrapt_fun(x1, x2)


def egg_holder_function(x1, x2):
    return -(x2+47)*np.sin(np.sqrt(np.abs(x2+x1/2+47))) - x1*np.sin(np.sqrt(np.abs(x1-x2+47)))


def mpl_toolkits_test_function(x1, x2):
    x1=x1/10
    x2=x2/10
    z1 = np.exp(-(x1**2 + x2**2) / 2) / (2 * np.pi)
    z2 = (np.exp(-(((x1 - 1) / 1.5)**2 + ((x2 - 1) / 0.5)**2) / 2) /
          (2 * np.pi * 0.5 * 1.5))
    return z2-z1
    

def offset(x1, x2):
    return 5


def plane(grad_x1, grad_x2, x1, x2):
    """Plane with gradient 2, .5"""
    return grad_x1*x1+grad_x2*x2


def paraboloid(x1, x2):
    return 2*x1**2+10*x2**2


def approx_grad(*args, fun):
    f0 = fun(*args)
    dx = 1e-7
    dxs = np.eye(len(args))*dx
    jac = np.ones(len(args))
    pos_eval_points = np.ones((len(args), len(args)))+dx
    neg_eval_points = np.ones((len(args), len(args)))-dx
    for i, (pos_row, neg_row) in enumerate(zip(pos_eval_points, neg_eval_points)):
        pos_ans = fun(*pos_row)
        neg_ans = fun(*neg_row)
        if pos_ans==np.inf & neg_ans==np.inf:
            raise Exception(f"{args} in excluded area")
        elif neg_ans==np.inf:
            jac[i] = (pos_ans-f0)/dx
        elif pos_ans==np.inf:
            jac[i] = (f0-neg_ans)/dx
        else:
            jac[i] = (pos_ans-neg_ans)/(2*dx)
    return jac
